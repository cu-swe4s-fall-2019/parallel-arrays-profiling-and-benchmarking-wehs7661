# Parallel Arrays, Profiling, and Benchmarking
[![Build Status](https://travis-ci.com/cu-swe4s-fall-2019/parallel-arrays-profiling-and-benchmarking-wehs7661.svg?branch=master)](https://travis-ci.com/cu-swe4s-fall-2019/parallel-arrays-profiling-and-benchmarking-wehs7661)
## Description
This is a repository for Assignment 4 of the course Software Engineering for Scientise (CSCI7000) at CU Boulder, which includes the following files:
- `plot_gtex.py`: the code used for ploting the gene expression distribution across either tissue groups (SMTS), or tissue types (SMTSD) for a target gene
- `data_viz.py`: a Python code for plotting box plots
- `test_plot_gtex.py`: a Python code for the unit tests of the code `plot_gtex.py`
- `test_data_viz.py`: a Python code for the unit tests of the code `data_viz.py`
- `test_plot_gtex.sh`: a shell script for the functional tests of the code `plot_gtex.py`
- `plot_gtex.linear_search.txt` and `plot_gtex.binary_search.txt`: text files documenting the results of profiling of `plot_gtex.py` with either linear or binary searching method
- `ACTA2.png`: a series of boxplot generated by `plot_gtex.py` (see the Usage section for the command of generating this figure)
- `GTex_Analysis_*`: Datasets required for the execution of `plot_gtex.py`
- `.gitmodules` and `hash-tables-wehs7661 @ 44470e5`: Submodule added from `hash-tables-wehs7661`, the repository of Assignment 6

## Installation
All the Python scripts are written in Python 3 and the packages required to run the codes include: `gzip`, `unittest`, `random`, `sys`, `os`, `time`, `matplotlib` and `argparse`.

## Usage
### 1. Data acquirement
The execution of the codes relies on the data which can be obtained from the following sources:
- https://github.com/swe4s/lectures/blob/master/data_integration/gtex/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_reads.acmg_59.gct.gz?raw=true
- https://storage.googleapis.com/gtex_analysis_v8/annotations/GTEx_Analysis_v8_Annotations_SampleAttributesDS.txt

### 2. Execution of the main program <br/>
To run the main program `plot_gtex.py` to generate the figure `ACTA2.png`, run the command 
```
python plot_gtex.py --gene_reads  GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_reads.acmg_59.gct.gz --sample_attributes GTEx_Analysis_v8_Annotations_SampleAttributesDS.txt --gene ACTA2 --group_type SMTS --output_file ACTA2.png --data_structure parallel
```
To use hash tables instead of parallel arrays, specified the flag `data_structure` as `hash` instead.

### 3. Unit test
- To perform unit tests for `data_viz.py`, run the command 
```
python test_data_viz.py
```
- To perform the unit tests for `plot_gtex.py`, run the command
```
python test_plot_gtex.py
```
### 4. Functional test <br/>
To perform functional tests of `plot_gtex.py`, run the command,
```
bash test_plot_gtex.sh
```

## Profiling and benchmarking
### 1. Profiling using `cProfile`
To figure out which part of the code in the main program `plot_gtex.py` takes most of the time, we use the `cProfile` module to performing profiling on the code using the following command:
```
python -m cProfile -s tottime plot_gtex.py --gene_reads  GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_reads.acmg_59.gct.gz --sample_attributes GTEx_Analysis_v8_Annotations_SampleAttributesDS.txt --gene ACTA2 --group_type SMTS --output_file ACTA2.png > plot_gtex.linear_search.txt
```
As a result, it took 18.940 seconds for the program to complete the task, in which the function `linear_search` accounts for 14.527 seconds (76.846%). Therefore, to enhance the performance of the main program, starting with improving the searching method would be the most reasonable choice, which is the motivation of the development of another seaerching method: `binary_search`. Replacing the searching method with the function `binary_search` and performing profiling again, from the results documented in `plot_gtex.binary_search.txt`, we can see that the time required to generate the boxplots was significantly reduced to 1.623 seconds, in which the searching of the data accounts for a very small amount of time. This is how we can identify the part of the code which has biggest room for improvments and improve it accordingly using the concept of profiling.

### Benchmarking
To test the resources used by the program, we also performed benchinmarking, using either the GNU `time` program or the Python module `time`.

#### GNU `time` program 
- Parallel arrays with linear searching method (`linear_search`)
  - Command
  ```
  /usr/bin/time -f '%e\t%M' python plot_gtex.py --gene_reads  GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_reads.acmg_59.gct.gz --sample_attributes GTEx_Analysis_v8_Annotations_SampleAttributesDS.txt --gene ACTA2 --group_type SMTS --output_file ACTA2.png --data_structure parallel
  ```
  - Result
    - Elapsed time: 17.86 seconds
    - Maximum memory usage: 82724 KB
- Parallel arrays with binary searching method (`binary_search`)
  - Command: same as the one used above
  - Result
    - Elapsed time: 0.61 seconds
    - Maximum memory usage: 61660 KB

- Hash tables
  -Command
  ```
  /usr/bin/time -f '%e\t%M' python plot_gtex.py --gene_reads  GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_reads.acmg_59.gct.gz --sample_attributes GTEx_Analysis_v8_Annotations_SampleAttributesDS.txt --gene ACTA2 --group_type SMTS --output_file ACTA2.png --data_structure hash
  ```
  - Result
    - Elapsed time: 0.58 seconds
    - Maximum memory usage: 61636 KB

- Discussion 
As shown above, for the parallel arrays, the binary search method is significantly faster than the linear search method while at the same time, takes less memory space, which validates that the binary method is apparently better than the linear method. On the other hand, comparing hash tables to parallels, we can see that the hash table is also much faster than the parllel arrays with the linear method. It is also slightly faster than the binary method, but is basically at the same order of magnitude as the parallel arrays with binary method. (Also, they take up about the same amount of memory space.) From this result, we can tell that hash table is generally a better data structure than the parallel arrays, especially when the searching method used in parllel arrays is not good enough. 

### Python module `time`
In this section, the part of searching data in the `main` function was timed by the Python module `time`. As a result, it took about 17.008 and 0.984 seconds for the program to run through the whole searching loop, for the lienar and binary searching method, respectively. This again, shows that the binary searching method is superior to the linear searching method.

## Changes made upon the starter code of Assignment 4
- Developed the main program `plot_gtex.py`, the code used for ploting the gene expression distribution across either tissue groups (SMTS), or tissue types (SMTSD) for a target gene.
- Developed the unit tests (`test_plot_gtex.py`) and functional tests (`plot_gtex.sh`) of the main program `plot_gtex.py`.
- Developed `data_viz.py`, a Python code for plotting box plots, and its corresponding code for unit tests: `test_data_viz.py`
- Performed profiling on the main program and output the results to `plot_gtex.linear_search.txt` and `plot_gtex.binary_search.txt`.
- Generated and saved a series of boxplots as `ACTA2.png` based on the datasets `GTex_Analysis_*` downloaded from the urls provided above.
- Performed benchmarking on the main program and updated `README` accordingly.
- Made sure that all the Python codes conform with the best practices, including docstring and PEP8 coding style.
- Edited `.travis.yml` to pass the continuous integration performed by TravisCI.

